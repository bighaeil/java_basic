/**
 * 규칙
 * 1. 내가 이해한 핵심 내용만 간략히
 * 2. 모르면 넘어가기
 * 3. 다시 읽을 때 확인
 */
#11 - equals 를 재정의하려거든 hashCode 도 재정의하라
이유 - equals 는 논리적(값)으로 같다고 판단하면 true -> Object 는 다르다고 판달할 것임
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(010, 1234, 5678), "제니");
m.get(new PhoneNumber(010, 1234, 5678), "제니"); // return = null 논리적으로 값은 같지만, 인스턴스(Object)는 다르다.
해결 - hashCode 메서드를 재정의
#12 - toString 을 항상 재정의하라
#13 - clone 재정의는 주의해서 진행하라
#14 - Comparable을 구현할지 고려하라
특징 - Comparable - equals 와 비슷 - 숫서까지 비교 - 제네릭 - 순서가 명확한 값 클래스 작성한다면 Comparable 인터페이스 구현
#15 클래스와 멤버의 접근 권한을 최소화하라
정보은닉, 캡슐화 - 컴포넌트의 모든 내부 구현을 완벽히 숨겨, 구현과 API 를 깜끌히 분리 - 서로의 내부 동작 방식에는 전혀 개의치 않음 - 접근 제한자를 제대로 활용
단계
1. 접근은 최대한 줄인다 - private
2. 같은 패키지의 다른 클래스의 멤버가 접근해야 한다면 - package-private
3. 너무 자주 풀어준다면 - 컴포넌트를 분해
public static final 은 안전하지 않다.(?)
해결
- private 으로 만들고 - public 불변 리스트
- private 으로 만들고 - 복사본 반환
#16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
필드를 private 으로 바꾸고 - public 접근자(getter) 추가
불변 필드 (public final) - 노출해도 덜 위험하지만 완전히 안심할 수 없다.
#17 - 변경 가능성을 최소화하라
불변 클래스 - 구현 쉽다. 안전. 오류 생길 여지 적음
- 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드 final
- 모든 필드 private
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없다.
불변 객체 - 스레드에 안전(동기화할 필요 없음) - 안심하고 공유 - 불변 객체끼리는 내부 데이터를 공유
단점 - 값이 다르면 독립된 객체를 만들어야됨
#18 - 상속 보다는 컴포지션을 사용하라
컴포지션(composition 구성) - 기존 클래스를 확장하는 대신 - 새로운 클래스 - private 필드로 기존 클래스의 인스턴스로 참조 - 기존 클래스가 새로운 클래스의 구성요소로 쓰임
#19 - 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
#20 - 추상 클래스보다는 인터페이스를 우선하라
